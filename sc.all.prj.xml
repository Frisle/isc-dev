<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2016.2 (Build 728U)">
<Project name="sc-all">
  <Items>
    <ProjectItem name="sc.all" type="CLS"></ProjectItem>
    <ProjectItem name="sc.all.sub" type="CLS"></ProjectItem>
  </Items>
</Project>


<Class name="sc.all">
<Description>

UDL export/import all for ISC Cach√© 2016.2
Usage:
w ##class(sc.all).workdir( "c:\your\work\dir\")
d ##class(sc.all).export()
d ##class(sc.all).import()
</Description>
<Abstract>1</Abstract>

<Method name="export">
<Description>
export all available code</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>generated=0,system=0,percent=0,mapped=1</FormalSpec>
<Implementation><![CDATA[
		
	#define export(%code, %file) $system.OBJ.ExportUDL(%code, %file,"/diffexport")
	#define isGenerated(%code) ##class(%RoutineMgr).IsGenerated( %code )	
	#define isPercented(%code) ("%" = $e(%code))
	#define isMapped(%code) ##class(%RoutineMgr).IsMapped( %code )
	#define log w !, code, " -> ", filename, " "
		
	#; classes 
	s rs = ##class(%ResultSet).%New("%Dictionary.ClassDefinition:Summary")
	if rs.Execute() {
		
		while rs.%Next(){
			
			s code = rs.Name _ ".cls", isSystem = rs.System
			if ( 'system && isSystem ) continue
			if ( 'generated && $$$isGenerated( code ) ) continue
			if ( 'percent && $$$isPercented( code ) ) continue
			if ( 'mapped && $$$isMapped( code ) ) continue
			s filename = ..filename( code )
			$$$log
			w $$$export( code, filename )
			
		} s rs=""
	} 
	
	#; routines
	s rs = ##class(%ResultSet).%New("%Routine:RoutineList")
	if rs.Execute() {
		
    	while rs.%Next() {
	    	
	 		s code = rs.Name
	 		if ( 'generated && $$$isGenerated( code ) ) continue
	 		if ( 'percent && $$$isPercented( code ) ) continue
			if ( 'mapped && $$$isMapped( code ) ) continue
			
			s filename = ..filename( code )
			$$$log
			w $$$export( code, filename )
			
	    } s rs=""
	}
	
	
	#; dfi
	#define export(%code, %file)  ##class(%DeepSee.UserLibrary.Utils).%Export( %code, %file, 0 )
	s sql = "Select fullName as Name From %DeepSee_UserLibrary.FolderItem"
    s rs = ##class(%SQL.Statement).%ExecDirect( .stm, sql )
    while rs.%Next() {
		s code = rs.Name, filename = ..filename( code_".dfi" )
		$$$log
		w $$$export( code, filename )
		
	} s rs=""
	
    Q
]]></Implementation>
</Method>

<Method name="import">
<Description>
import all from workdir</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[qspec="cku-d",&err="",recurse=1,&loaded="",verbose=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define push(%dir) s dirs( $i( dirs ) ) = %dir
	#define next(%i,%dir) s %i=$o( dirs( "" ), 1, %dir )  k:%i'="" dirs(%i)
	#define isDirectory(%type) ( %type = "D" )
	#define log w !, filename, " ", +sc
	
	s sc = 1, dirs = "", dir = ..workdir() $$$push(dir)
		
	s rs = ##class(%ResultSet).%New( "%Library.File:FileSet" )
	for { $$$next(i,dir) Q:i=""  Q:dir=""
		
		s sc = rs.Execute( dir, "*.*" ) Q:'sc
		
		while rs.Next() {
			
		   s filename = rs.Name
		   
		   if $$$isDirectory(rs.Type) {
			 
			 if recurse $$$push(filename) 
			 continue  
			 
		   }
		  
		   s ext = $p(filename, ".", *)
		   if $zcvt(ext,"l") = "dfi" {
			   
			   s sc = ##class(%DeepSee.UserLibrary.Utils).%Import( filename, 1, 0, 0, "", .loaded )
		   
		   } else {
			   
			   s sc = $system.OBJ.Load( filename, qspec, .err, .loaded)
			   
		   }
		   
		   if verbose $$$log
		   
	    }
	}
		
	Q sc
]]></Implementation>
</Method>

<Method name="filename">
<Description>
Translate ( codename ) into ( filename )</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>code</FormalSpec>
<Implementation><![CDATA[
	s wd = ..workdir() 
	d:'##class(%File).DirectoryExists( wd ) ##class(%File).CreateDirectoryChain( wd )
	s filename = ##class(%File).NormalizeFilename( code, wd )
	#; for *.dfi filename can contain folders
	s path = ##class(%File).GetDirectory(filename) 
	d:'##class(%File).DirectoryExists( path ) ##class(%File).CreateDirectoryChain( path )
	Q filename
]]></Implementation>
</Method>

<Method name="workdir">
<Description>
get or set working directory for export/import source</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>workdir</FormalSpec>
<Implementation><![CDATA[
	s gln = ..gln() s:$d(workdir) @gln = workdir
	///zu(12) namespace directory by default
	#define nsdir $zu(12,"") 
	Q $g(@gln, $$$nsdir)
]]></Implementation>
</Method>

<Method name="gln">
<Description>
gl[obal] n[ame] - storage for settings</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<Private>1</Private>
<Implementation><![CDATA["^"_$classname()
]]></Implementation>
</Method>
</Class>


<Class name="sc.all.sub">
<Description>
Export different types of modules in different subfolders</Description>
<Super>sc.all</Super>

<Method name="filename">
<Description><![CDATA[
test.dfi -> /dfi/test.dfi
test.cls -> /cls/test.cls
etc]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>code</FormalSpec>
<Implementation><![CDATA[
	s ext = $p( code, ".", * ), ext = $zcvt( ext, "l" )
	#; for each type - different directory
	s wd = ..workdir() s:ext'="" wd = ##class(%File).NormalizeDirectory( ext, wd ) 
	d:'##class(%File).DirectoryExists( wd ) ##class(%File).CreateDirectoryChain( wd )
	
	s filename = ##class(%File).NormalizeFilename( code, wd )
	#; for *.dfi filename can contain folders
	if ext = "dfi" {
		s path = ##class(%File).GetDirectory( filename ) 
		d:'##class(%File).DirectoryExists( path ) ##class(%File).CreateDirectoryChain( path )
	}
	Q filename
]]></Implementation>
</Method>

<Method name="importUpdated">
<Description>
import from workdir all files with ts newer than code ts in db</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[qspec="cku-d",&err="",recurse=1,&loaded="",verbose=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#define push(%dir) s dirs( $i( dirs ) ) = %dir
	#define next(%i,%dir) s %i=$o( dirs( "" ), 1, %dir )  k:%i'="" dirs(%i)
	#define isDirectory(%type) ( %type = "D" )
	#define log w !, filename, " -> ", codename, " ", +sc
	
	s sc = 1, dirs = "", dir = ..workdir() $$$push(dir)
		
	s rs = ##class(%ResultSet).%New( "%Library.File:FileSet" )
	for { $$$next(i,dir) Q:i=""  Q:dir=""
		
		s sc = rs.Execute( dir, "*.*" ) Q:'sc
		
		while rs.Next() {
		   
		   s filename = rs.Name 		   
		   
		   if $$$isDirectory( rs.Type ) {
			 if ( recurse ) $$$push(filename) ;push directory 
			 continue  
		   }
		   
		   s filets = rs.DateModified
		   s codename = ..codename( filename, .ext )      
		   s codets = ..codets( codename, ext )
		   
		   if ( filets '] codets ) continue
		   
		   /*
		   w !, " ************* import ************** "
		   w !, "file: ", filets
		   w !, "code: ", codets
		   */
		   
		   if ext = "dfi" {
			   
			   s sc = ##class(%DeepSee.UserLibrary.Utils).%Import( filename, 1, 0, 0, "", .loaded )
		   
		   } else {
			   
			   s sc = $system.OBJ.Load( filename, qspec, .err, .loaded)
			   
		   }
		   
		   if verbose $$$log
	    }
	}
	Q sc
]]></Implementation>
</Method>

<Method name="codename">
<Description>
presumable codename </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[filename,&ext=""]]></FormalSpec>
<Implementation><![CDATA[
	s ext = $p( filename, ".", * ), ext = $zcvt( ext, "l" )
	s path = ##class(%File).NormalizeDirectory( ext, ..workdir() )
	s codename = $p( filename, path, 2 )
	if ext = "dfi" {
		s fullname  = $tr( codename, "\", "/" ) ; return fullname for dfi in $$$IsWINDOWS
		Q $p( fullname, ".", 1, *-1 ) ;remove extension 
	}
	Q codename
]]></Implementation>
</Method>

<Method name="codets">
<ClassMethod>1</ClassMethod>
<FormalSpec>codename,ext</FormalSpec>
<Implementation><![CDATA[
	s ts = ""
	if ext'="dfi" {
		s ts = ##class(%RoutineMgr).TS( codename )
	} else {
		s sql="Select timeModified From %DeepSee_UserLibrary.FolderItem Where fullname = ?"	
		s rs = ##class(%SQL.Statement).%ExecDirect( , sql, codename )
		if rs.%Next() { 
			s utcts = rs.timeModified
			s utch = $zdth( utcts, 3, , 3 ) ;utc internal format
			s loch = $zdth( utch, -3 ) ; utc to local timezone
			s ts = $zdt( loch, 3, ,0 ) ; local timestamp*/
		}
	}
	Q $p( ts, "." ) ;remove ms
]]></Implementation>
</Method>
</Class>
</Export>
